package ;

import haxe.CallStack;
import haxe.PosInfos;

import util.LogUtil;

using StringTools;

class Err {
  public var msg (default,null) : String;
  public var pos (default,null) : PosInfos;
  public var stack (default,null) : String;

  public function new (message:String, ?constrct_pos:PosInfos) : Void
    {
      msg = message;
      pos = constrct_pos;
      stack = LogUtil.get_readable_stack(1);
    }

  public function toString () : String
    {
      var class_name = LogUtil.get_cls_s(this);
      var position  = LogUtil.get_pos_s(pos);
      var s = '$class_name:\n\t$msg\n\tGenerated by $position\n$stack';
      return s;
    }

  public function log(msg_prefix:String="Logging error:") {
    trace('${msg_prefix}\n\t${LogUtil.get_cls_s(this)}: $msg \n\tFrom ${LogUtil.get_pos_s(pos)}');
    // LogUtil.display_error(this);
  }

  // Force Boot.cast to use async_throw
#if js
  private static var _boot_cast_err = (function() {

    // Get call location of cast (0==this, 1==hxglobal, 2==cast)
    function get_callstack() {
      var cs:Dynamic = haxe.CallStack.callStack();
        return untyped __js__('" at "+{0}[2][3].replace(/.*\\//, "")+":"+{0}[2][4]', cs);
    }

    untyped __js__('{1}.__cast = function(o,t) {
if ({1}.__instanceof(o,t)) return o;
var msg = "Cast error: cannot cast "+Std.string(o)+" to "+Type.getClassName(t)+{0}();
LogUtil.async_throw(msg);
throw msg;
}', get_callstack, js.Boot);
    return true;
  })();
#end

}
